"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isBridgeHandler = exports.BridgeHandler = void 0;
const handler_1 = require("../handler");
const middleware_1 = require("./middleware");
const resolver_1 = require("./resolver");
const data_validator_1 = require("./data-validator");
const file_validator_1 = require("./file-validator");
class BridgeHandler extends handler_1.AbstractHandler {
    config;
    handler;
    resolve;
    constructor(config) {
        super();
        this.config = config;
        this.resolve = config.resolve;
        if (config.bodySchema && !config.resolve.length)
            throw Error(`You can't have no argument in your resolve function with a bodySchema specification`);
        if (config.querySchema && !config.resolve.length)
            throw Error(`You can't have no argument in your resolve function with a querySchema specification`);
        if (config.headersSchema && !config.resolve.length)
            throw Error(`You can't have no argument in your resolve function with a headersSchema specification`);
        if (config.fileConfig && !config.resolve.length)
            throw Error(`You can't have no argument in your resolve function with a fileConfig specification`);
        if (config.bodySchema && config.fileConfig)
            throw Error("You can't get a JSON body and files in the same endpoint.");
        const firstHandler = new handler_1.FirstHandler();
        let handler = firstHandler;
        if (config.bodySchema)
            handler = handler.setNext(new data_validator_1.DataValidator(config.bodySchema, 'body'));
        if (config.querySchema)
            handler = handler.setNext(new data_validator_1.DataValidator(config.querySchema, 'query'));
        if (config.headersSchema)
            handler = handler.setNext(new data_validator_1.DataValidator(config.headersSchema, 'headers'));
        if (config.fileConfig)
            handler = handler.setNext(new file_validator_1.FileValidator(config.fileConfig));
        if (config.middlewares)
            handler = handler.setNext(new middleware_1.MiddelwaresHandler(config.middlewares));
        handler = handler.setNext(new resolver_1.Resolver(config.resolve));
        this.handler = firstHandler;
    }
    /**
     *
     * If the middleware returns an error, we stop the chain and return it
     * otherwise we add the result in the mid data of the next handler
     * If there is no next handler, we return the last result
     */
    handle = async (data) => {
        const res = await this.handler.handle(data);
        if (res && res.error)
            return res;
        data.mid = { ...res, ...data.mid };
        if (this.nextHandler)
            return this.nextHandler.handle(data);
        return res;
    };
}
exports.BridgeHandler = BridgeHandler;
const isBridgeHandler = (data) => data &&
    typeof data === 'object' &&
    typeof data.handler === 'object' &&
    typeof data.handle === 'function' &&
    typeof data.config === 'object' &&
    typeof data.config.resolve === 'function';
exports.isBridgeHandler = isBridgeHandler;
//# sourceMappingURL=bridge.js.map