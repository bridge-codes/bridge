import { AbstractHandler, Handler } from '../handler';
import { DataParser } from './data-validator';
import { FileConfig } from './file-validator';
export interface BridgeHandlerDocumentation {
    title?: string;
    text?: string;
}
export declare class BridgeHandler<Resolve extends (...args: any[]) => any = any, Middlewares extends ReadonlyArray<BridgeHandler> = any> extends AbstractHandler {
    config: {
        resolve: Resolve;
        bodySchema?: DataParser;
        querySchema?: DataParser;
        headersSchema?: DataParser;
        fileConfig?: FileConfig;
        middlewares?: Middlewares;
        documentation?: BridgeHandlerDocumentation;
    };
    private handler;
    resolve: Resolve;
    constructor(config: {
        resolve: Resolve;
        bodySchema?: DataParser;
        querySchema?: DataParser;
        headersSchema?: DataParser;
        fileConfig?: FileConfig;
        middlewares?: Middlewares;
        documentation?: BridgeHandlerDocumentation;
    });
    /**
     *
     * If the middleware returns an error, we stop the chain and return it
     * otherwise we add the result in the mid data of the next handler
     * If there is no next handler, we return the last result
     */
    handle: Handler['handle'];
}
export declare const isBridgeHandler: (data: any) => data is BridgeHandler<any, any>;
//# sourceMappingURL=bridge.d.ts.map